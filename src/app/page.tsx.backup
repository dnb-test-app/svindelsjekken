'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { Button, Textarea, Logo, Dropdown, Badge, P, Heading } from '@dnb/eufemia';


export default function Home() {
  const [text, setText] = useState('');
  const [result, setResult] = useState<any>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [showModelSelector, setShowModelSelector] = useState(false);
  const [selectedModel, setSelectedModel] = useState('openai/gpt-4o-mini');
  const [defaultModel, setDefaultModel] = useState('openai/gpt-4o-mini');
  const [hasUserSelectedModel, setHasUserSelectedModel] = useState(false);
  const [pendingModel, setPendingModel] = useState<string>('');
  const [aiAnalysis, setAiAnalysis] = useState<any>(null);
  
  // Dynamic models state
  const [availableModels, setAvailableModels] = useState<any[]>([]);
  const [isLoadingModels, setIsLoadingModels] = useState(false);
  const [modelsFetched, setModelsFetched] = useState(false);
  const [testingModel, setTestingModel] = useState<string | null>(null);
  const [modelTestResults, setModelTestResults] = useState<Record<string, any>>({});
  const [batchTesting, setBatchTesting] = useState(false);
  const [modelFilter, setModelFilter] = useState('');
  
  // Image upload states
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [isProcessingImage, setIsProcessingImage] = useState(false);
  const [ocrProgress, setOcrProgress] = useState<number>(0);

  // Context refinement states
  const [contextText, setContextText] = useState('');
  const [isRefiningAnalysis, setIsRefiningAnalysis] = useState(false);
  const [originalText, setOriginalText] = useState('');
  const [followUpQuestions, setFollowUpQuestions] = useState<string[]>([]);
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Load saved model preference and test results
  useEffect(() => {
    // Load test results from localStorage
    const savedTestResults = localStorage.getItem('modelTestResults');
    if (savedTestResults) {
      try {
        setModelTestResults(JSON.parse(savedTestResults));
      } catch (e) {
        console.error('Failed to parse saved test results');
      }
    }
    
    fetch('/api/analyze-advanced')
      .then(res => res.json())
      .then(data => {
        const apiDefaultModel = data.defaultModel || 'openai/gpt-4o-mini';
        setDefaultModel(apiDefaultModel);

        const saved = localStorage.getItem('selectedAIModel');
        const selectedModelId = saved || apiDefaultModel;
        setSelectedModel(selectedModelId);
        setHasUserSelectedModel(saved !== null && saved !== apiDefaultModel);
      })
      .catch(() => {
        // Fallback if API fails
        const fallbackDefault = 'openai/gpt-4o-mini';
        setDefaultModel(fallbackDefault);

        const saved = localStorage.getItem('selectedAIModel');
        const selectedModelId = saved || fallbackDefault;
        setSelectedModel(selectedModelId);
        setHasUserSelectedModel(saved !== null && saved !== fallbackDefault);
      });
  }, []);

  // Fetch available models from API (with optional fresh fetch)
  const fetchAvailableModels = useCallback(async (forceFresh = false) => {
    if (!forceFresh && modelsFetched) return;
    if (isLoadingModels) return;
    
    setIsLoadingModels(true);
    try {
      const url = forceFresh ? '/api/fetch-models?fresh=true' : '/api/fetch-models';
      const response = await fetch(url);
      
      if (response.ok) {
        const data = await response.json();
        console.log(`Fetched ${data.totalModels} models (${data.verifiedCount} verified)`);
        
        if (data.models && data.models.length > 0) {
          setAvailableModels(data.models);
          setModelsFetched(true);
          
          // Store in localStorage for quick loading
          localStorage.setItem('cachedModels', JSON.stringify({
            timestamp: data.timestamp,
            models: data.models
          }));
          
          // If current model isn't in the list, switch to recommended
          const currentModelAvailable = data.models.some((m: any) => m.id === selectedModel);
          if (!currentModelAvailable && data.recommended) {
            setSelectedModel(data.recommended.id);
            localStorage.setItem('selectedAIModel', data.recommended.id);
          }
        }
      } else {
        console.error('Failed to fetch models:', response.status);
      }
    } catch (error) {
      console.error('Failed to fetch models:', error);
    } finally {
      setIsLoadingModels(false);
    }
  }, [modelsFetched, isLoadingModels, selectedModel]);

  // Easter egg: Check for "RaiRai" in text
  useEffect(() => {
    if (text.toLowerCase().includes('rairai') && !showModelSelector) {
      setShowModelSelector(true);
      fetchAvailableModels(); // Fetch models when admin mode is activated
    }
  }, [text, showModelSelector, fetchAvailableModels]);


  // Process uploaded file
  const processFile = useCallback(async (file: File) => {
    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      alert('Filen er for stor. Maksimal størrelse er 10MB.');
      return;
    }

    setIsProcessingImage(true);
    setOcrProgress(0);

    // Track all intervals for cleanup
    const intervals: NodeJS.Timeout[] = [];

    // Smooth progress animation
    let currentProgress = 0;
    const progressInterval = setInterval(() => {
      currentProgress += Math.random() * 3 + 1; // Increment by 1-4%
      if (currentProgress > 18) currentProgress = 18; // Cap at 18% before first milestone
      setOcrProgress(Math.floor(currentProgress));
    }, 200);
    intervals.push(progressInterval);
    
    // Show preview for images
    if (file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = (e) => setImagePreview(e.target?.result as string);
      reader.readAsDataURL(file);
    }
    
    try {
      if (file.type.startsWith('image/') || file.type === 'application/pdf') {
        // Prepare form data
        const formData = new FormData();
        formData.append('image', file);
        formData.append('model', selectedModel);

        // Update progress milestone
        intervals.forEach(clearInterval);
        intervals.length = 0;
        setOcrProgress(20);

        // Continue smooth progress
        let progress20to50 = 20;
        const progressTo50 = setInterval(() => {
          progress20to50 += Math.random() * 3 + 2;
          if (progress20to50 > 50) progress20to50 = 50;
          setOcrProgress(Math.floor(progress20to50));
        }, 300);
        intervals.push(progressTo50);

        // Send to API for OCR and analysis
        const response = await fetch('/api/analyze-image', {
          method: 'POST',
          body: formData
        });

        intervals.forEach(clearInterval);
        intervals.length = 0;
        setOcrProgress(60);

        // Continue progress while processing response
        let progress60to85 = 60;
        const progressTo85 = setInterval(() => {
          progress60to85 += Math.random() * 2 + 1;
          if (progress60to85 > 85) progress60to85 = 85;
          setOcrProgress(Math.floor(progress60to85));
        }, 200);
        intervals.push(progressTo85);
        
        if (!response.ok) {
          throw new Error('Kunne ikke analysere bildet');
        }
        
        const result = await response.json();
        intervals.forEach(clearInterval);
        intervals.length = 0;
        setOcrProgress(90);

        // Final progress animation
        setTimeout(() => setOcrProgress(95), 100);
        setTimeout(() => setOcrProgress(100), 200);
        
        if (result.error) {
          throw new Error(result.error);
        } else if (result.extractedText) {
          // Don't put extracted text in the text field - keep image analysis separate
          // setText(result.extractedText); // REMOVED - prevents confusion

          // If API already provided analysis, use it
          const resultData: any = {
            category: result.category || 'safe',
            risk: result.riskLevel || 'low',
            triggers: result.mainIndicators?.map((ind: string) => ({
              pattern: ind,
              category: 'api_detected',
              weight: 10
            })) || [],
            categories: ['api_analysis'],
            aiEnhanced: true,
            recommendation: result.recommendation,
            summary: result.summary,
            isImageAnalysis: true, // Mark this as image analysis
            extractedText: result.extractedText // Store but don't show in input
          };

          // Only add score for fraud category
          if (result.category === 'fraud' && result.fraudProbability !== undefined) {
            resultData.score = result.fraudProbability;
          }

          setResult(resultData);
        } else {
          // No analysis available, mark as safe
          setResult({
            category: 'safe',
            score: 0,
            risk: 'low',
            triggers: [],
            categories: [],
            recommendation: 'Kunne ikke analysere bildet',
            summary: 'Analyse ikke tilgjengelig'
          });
        }
      }
    } catch (error: any) {
      // Clear all intervals on error
      intervals.forEach(clearInterval);
      console.error('Feil ved prosessering av fil:', error);
      const errorMessage = error.message || 'Kunne ikke lese tekst fra filen';
      alert(`Feil: ${errorMessage}. Hvis problemet vedvarer, prøv et annet bilde.`);
    } finally {
      // Clear any remaining intervals
      intervals.forEach(clearInterval);
      setTimeout(() => {
        setIsProcessingImage(false);
        setOcrProgress(0);
      }, 500); // Small delay to show 100% completion
    }
  }, [selectedModel]);

  // Handle file input change
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      processFile(file);
    }
  };

  // Handle drag and drop
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    
    const file = e.dataTransfer.files?.[0];
    if (file) {
      processFile(file);
    }
  };

  // Handle paste
  useEffect(() => {
    const handlePaste = (e: ClipboardEvent) => {
      const items = e.clipboardData?.items;
      if (!items) return;
      
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
          const file = items[i].getAsFile();
          if (file) {
            processFile(file);
            e.preventDefault();
            break;
          }
        }
      }
    };
    
    document.addEventListener('paste', handlePaste);
    return () => document.removeEventListener('paste', handlePaste);
  }, [processFile]);

  const handleCheck = async () => {
    if (text.trim().length < 5 && !imagePreview) return;

    setIsAnalyzing(true);
    setAiAnalysis(null);
    setResult(null); // Clear previous results

    // Clean text for API
    const cleanedText = text.replace(/rairai/gi, '').trim();

    // Store original text for context refinement
    setOriginalText(cleanedText);
    
    // Try AI analysis first if text is long enough
    if (cleanedText.length >= 5) {
      try {
        const modelToUse = typeof selectedModel === 'string' ? selectedModel : defaultModel;
        const response = await fetch('/api/analyze-advanced', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            text: cleanedText,
            model: modelToUse
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('API error:', errorText);

          // Check if it's a rate limit error
          let errorMessage = 'AI-analyse utilgjengelig.';
          let recommendation = 'Analyse utilgjengelig - vær ekstra forsiktig';
          let summary = 'Kunne ikke analysere innholdet på grunn av tekniske problemer';

          if (response.status === 429) {
            errorMessage = 'For mange forespørsler. Vennligst vent et øyeblikk og prøv igjen.';
            recommendation = 'Vent og prøv igjen - vær ekstra forsiktig i mellomtiden';
            summary = 'Midlertidig utilgjengelig på grunn av høy trafikk';
          }

          // AI failed, use error category to warn user
          setResult({
            category: 'error',
            score: 0,
            risk: 'unknown',
            triggers: [],
            categories: [],
            fallbackMode: true,
            recommendation: recommendation,
            summary: summary,
            retryable: response.status === 429
          });
          setAiAnalysis({
            error: errorMessage
          });
        } else {
          const aiResult = await response.json();
          setAiAnalysis(aiResult);
          
          // Use AI-based risk assessment with categories
          const resultData: any = {
            category: aiResult.category || 'safe',
            risk: aiResult.riskLevel || 'low',
            triggers: aiResult.mainIndicators?.map((ind: string) => ({
              pattern: ind,
              category: 'ai_detected',
              weight: 10
            })) || [],
            categories: ['ai_analysis'],
            aiEnhanced: true,
            recommendation: aiResult.recommendation,
            summary: aiResult.summary
          };

          // Only add score for fraud category
          if (aiResult.category === 'fraud' && aiResult.fraudProbability !== undefined) {
            resultData.score = aiResult.fraudProbability;
          }

          setResult(resultData);

          // Set follow-up questions for prominent display
          if (Array.isArray(aiResult.followUpQuestions)) {
            setFollowUpQuestions(aiResult.followUpQuestions);
          } else {
            // Fallback questions if AI didn't provide them
            setFollowUpQuestions([
              'Har du mer informasjon om situasjonen?',
              'Forventet du denne kontakten?',
              'Virker noe mistenkelig på deg?'
            ]);
          }
        }
      } catch (error: any) {
        console.error('AI analysis failed:', error);
        
        // AI failed, use error category to warn user
        setResult({
          category: 'error',
          score: 0,
          risk: 'unknown',
          triggers: [],
          categories: [],
          fallbackMode: true,
          recommendation: 'Analyse feilet - vær ekstra forsiktig',
          summary: 'Kunne ikke analysere innholdet på grunn av tekniske problemer'
        });
        setAiAnalysis({
          error: 'AI-analyse feilet.'
        });
      }
    } else {
      // Text too short for analysis
      setResult({
        category: 'safe',
        score: 0,
        risk: 'low',
        triggers: [],
        categories: [],
        fallbackMode: true,
        recommendation: 'Tekst for kort for analyse',
        summary: 'Minimum 5 tegn kreves'
      });
    }

    setIsAnalyzing(false);
  };

  // Handle clicking on suggested questions
  const handleQuestionClick = (question: string) => {
    // Append to existing context or set as new context
    setContextText(prev =>
      prev.trim() ? `${prev}\n\n${question}` : question
    );
  };

  // Context refinement function
  const handleContextRefinement = async () => {
    if (!contextText.trim() || !originalText) return;

    setIsRefiningAnalysis(true);

    try {
      const modelToUse = typeof selectedModel === 'string' ? selectedModel : defaultModel;
      const response = await fetch('/api/analyze-advanced', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: originalText,
          context: contextText,
          model: modelToUse
        })
      });

      if (!response.ok) {
        throw new Error('Context refinement failed');
      }

      const refinedResult = await response.json();

      // Update the result with refined analysis
      const resultData: any = {
        category: refinedResult.category || 'safe',
        riskLevel: refinedResult.riskLevel,
        risk: refinedResult.riskLevel,
        triggers: refinedResult.mainIndicators?.map((indicator: string) => ({
          phrase: indicator,
          type: 'context_refined',
          weight: 10
        })) || [],
        categories: ['context_refined'],
        aiEnhanced: true,
        contextRefined: true,
        recommendation: refinedResult.recommendation,
        summary: refinedResult.summary
      };

      // Only add score for fraud category
      if (refinedResult.category === 'fraud' && refinedResult.fraudProbability !== undefined) {
        resultData.score = refinedResult.fraudProbability;
      }

      setResult(resultData);

      // Update AI analysis state
      setAiAnalysis(refinedResult);

      // Clear context for next use
      setContextText('');

    } catch (error) {
      console.error('Context refinement failed:', error);
      // Could show an error message to user
    } finally {
      setIsRefiningAnalysis(false);
    }
  };

  const handleModelChange = (e: any) => {
    console.log('Dropdown change event:', e); // Debug logging
    
    // DNB Dropdown passes { data: { value, content, ... } }
    let model = null;
    
    if (typeof e === 'string') {
      model = e;
    } else if (e?.data?.value) {
      model = e.data.value;
    } else if (e?.value) {
      model = e.value;
    }
    
    console.log('Extracted model:', model); // Debug logging
    console.log('Current selectedModel:', selectedModel); // Debug logging
    
    if (model && model !== selectedModel) {
      console.log('Setting pendingModel to:', model); // Debug logging
      setPendingModel(model);
    }
  };

  const handleSaveModel = () => {
    if (pendingModel) {
      setSelectedModel(pendingModel);
      setHasUserSelectedModel(pendingModel !== defaultModel);
      localStorage.setItem('selectedAIModel', pendingModel);
      setPendingModel('');
    }
  };

  const handleCancelModel = () => {
    setPendingModel('');
  };

  // Test a specific model
  const testModel = async (modelId: string) => {
    setTestingModel(modelId);
    
    try {
      const response = await fetch('/api/test-model', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ modelId }),
      });

      if (response.ok) {
        const result = await response.json();
        
        // Update test results
        const newResults = {
          ...modelTestResults,
          [modelId]: {
            working: result.working,
            supportsJson: result.supportsJson,
            error: result.error,
            errorType: result.errorType,
            testedAt: new Date().toISOString(),
            responseTime: result.responseTime
          }
        };
        
        setModelTestResults(newResults);
        localStorage.setItem('modelTestResults', JSON.stringify(newResults));
        
        // Update available models with test result
        setAvailableModels(prev => prev.map(model => 
          model.id === modelId 
            ? { 
                ...model, 
                status: result.working ? 'verified' : 'failed',
                working: result.working,
                supportsJson: result.supportsJson,
                lastTested: new Date().toISOString()
              }
            : model
        ));
      }
    } catch (error) {
      console.error('Failed to test model:', error);
    } finally {
      setTestingModel(null);
    }
  };

  // Test top models in batch
  const testTopModels = async () => {
    setBatchTesting(true);
    
    try {
      // Get top 50 untested or failed models
      const modelsToTest = availableModels
        .filter(m => m.status === 'untested' || m.status === 'failed')
        .slice(0, 50)
        .map(m => m.id);
      
      if (modelsToTest.length === 0) {
        alert('No models to test!');
        return;
      }
      
      const response = await fetch('/api/test-models-batch', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          modelIds: modelsToTest,
          testDepth: 'standard',
          maxConcurrent: 5
        }),
      });

      if (response.ok) {
        const data = await response.json();
        
        // Update test results for each model
        const newResults = { ...modelTestResults };
        data.results.forEach((result: any) => {
          newResults[result.modelId] = {
            working: result.working,
            supportsJson: result.supportsJson,
            errors: result.errors,
            accuracy: result.accuracy,
            responseTime: result.responseTime,
            testedAt: new Date().toISOString()
          };
        });
        
        setModelTestResults(newResults);
        localStorage.setItem('modelTestResults', JSON.stringify(newResults));
        
        // Update available models with test results
        setAvailableModels(prev => prev.map(model => {
          const testResult = data.results.find((r: any) => r.modelId === model.id);
          if (testResult) {
            return {
              ...model,
              status: testResult.working ? 'verified' : 'failed',
              working: testResult.working,
              supportsJson: testResult.supportsJson,
              accuracy: testResult.accuracy,
              lastTested: new Date().toISOString()
            };
          }
          return model;
        }));
        
        alert(`Tested ${data.statistics.totalTested} models:\n${data.statistics.working} working\n${data.statistics.withJsonSupport} with JSON support`);
      }
    } catch (error) {
      console.error('Batch test failed:', error);
      alert('Batch testing failed!');
    } finally {
      setBatchTesting(false);
    }
  };

  const getRiskMessage = () => {
    if (!result) return '';

    // Category-based messages
    if (result.category === 'fraud') {
      return '🚨 Svindelforsøk oppdaget';
    } else if (result.category === 'marketing') {
      return '📢 Kommersiell melding';
    } else if (result.category === 'suspicious') {
      return '⚠️ Mistenkelig innhold';
    } else if (result.category === 'safe') {
      return '🔒 Trygt innhold';
    } else if (result.category === 'error') {
      return '⚠️ Analyse utilgjengelig';
    }

    // Fallback to risk-based messages
    if (result.risk === 'high') {
      return '⚠️ Høy risiko';
    } else if (result.risk === 'medium') {
      return '⚡ Vær forsiktig';
    } else {
      return '✅ Ser trygt ut';
    }
  };

  const getRiskClass = () => {
    if (!result) return '';

    // Use category for styling if available
    if (result.category) {
      const categoryMap: Record<string, string> = {
        'fraud': 'high-risk',
        'marketing': 'marketing',
        'suspicious': 'medium-risk',
        'safe': 'low-risk'
      };
      return `result ${categoryMap[result.category] || result.risk}-risk`;
    }

    return `result ${result.risk}-risk`;
  };

  return (
    <div className="container">
      {/* Header */}
      <header className="header">
        <div className="header-left">
          <span className="tagline">T for Trygghet</span>
          <div>
            <Logo 
              height="28" 
              color="white"
              brand="ui"
            />
          </div>
        </div>
      </header>

      {/* Hero Section */}
      <section className="hero">
        <h1 className="hero-title">
          SVINDEL<br/>SJEKKEN
          <span className="checkmark">✓</span>
        </h1>
        <div className="hero-message">
          <p>Vi stopper 9 av 10 svindelforsøk.</p>
          <p className="hero-message-bold">Sammen kan vi stoppe resten.</p>
        </div>
      </section>

      {/* Main Input Section */}
      <main className="main">
        <div className="input-card">
          <label className="input-label">
            Er du usikker på om noe er svindel? Sjekk her:
          </label>
          
          {/* Hidden file input */}
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*,.pdf"
            onChange={handleFileChange}
            style={{ display: 'none' }}
          />
          
          {/* Textarea with drag and drop */}
          <div 
            className={`input-wrapper ${isDragging ? 'dragging' : ''}`}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <textarea
              className="input-field"
              placeholder="Lim inn mistenkelig tekst, link eller slipp bilde her"
              value={text}
              onChange={(e) => setText(e.target.value)}
              rows={4}
            />
            
            {/* Upload hint overlay */}
            {!text && !imagePreview && (
              <div className="upload-hint">
                💡 Tips: Du kan lime inn skjermbilde direkte med Ctrl+V / Cmd+V
              </div>
            )}
            
            {/* Drag overlay */}
            {isDragging && (
              <div className="drag-overlay">
                <div className="drag-message">
                  📷 Slipp bilde her
                </div>
              </div>
            )}
          </div>
          
          {/* Image preview */}
          {imagePreview && (
            <div className="image-preview">
              {/* eslint-disable-next-line @next/next/no-img-element */}
              <img src={imagePreview} alt="Opplastet bilde" />
              <button 
                className="remove-image"
                onClick={() => {
                  setImagePreview(null);
                  setText('');
                }}
              >
                ✕ Fjern bilde
              </button>
            </div>
          )}
          
          {/* OCR Progress */}
          {isProcessingImage && (
            <div className="ocr-progress">
              <div className="progress-label">
                {ocrProgress < 30 ? 'Laster opp bilde...' : 
                 ocrProgress < 70 ? 'Analyserer med AI...' : 
                 'Ferdigstiller analyse...'} {ocrProgress}%
              </div>
              <div className="progress-bar">
                <div className="progress-fill" style={{ width: `${ocrProgress}%` }}></div>
              </div>
            </div>
          )}

          {/* Hidden Model Selector - Easter Egg */}
          {showModelSelector && (
            <div style={{ marginTop: 'var(--spacing-small)', marginBottom: 'var(--spacing-small)' }}>
              {/* 🚀 REVOLUTIONARY INSTANT MODEL SWITCHING */}
              <div style={{
                background: 'linear-gradient(135deg, var(--color-sea-green) 0%, var(--color-mint-green) 100%)',
                color: 'white',
                padding: 'var(--spacing-medium)',
                borderRadius: '12px',
                marginBottom: 'var(--spacing-medium)',
                boxShadow: '0 8px 32px rgba(0, 114, 114, 0.2)'
              }}>
                {/* Header */}
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 'var(--spacing-medium)' }}>
                  <div>
                    <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: 'bold' }}>
                      🎛️ Model Control Center
                    </h3>
                    <p style={{ margin: '0.25rem 0 0 0', opacity: 0.9, fontSize: '0.875rem' }}>
                      Current: <strong>{selectedModel.split('/')[1] || selectedModel}</strong>
                    </p>
                  </div>
                  <Button
                    size="small"
                    variant="tertiary"
                    style={{ color: 'white', border: '1px solid white' }}
                    on_click={() => {
                    setShowModelSelector(false);
                    setSelectedModel(defaultModel);
                    setHasUserSelectedModel(false);
                    localStorage.removeItem('selectedAIModel');
                    setPendingModel('');
                    setText(''); // Clear the rairai text
                  }}
                >
                  Exit Admin Mode
                </Button>
              </div>

              {/* 🔥 INSTANT MODEL SWITCHING CARDS */}
              <div style={{
                background: 'rgba(255, 255, 255, 0.95)',
                borderRadius: '12px',
                padding: 'var(--spacing-medium)',
                marginBottom: 'var(--spacing-medium)',
                boxShadow: '0 4px 20px rgba(0, 0, 0, 0.1)'
              }}>
                <h4 style={{
                  margin: '0 0 var(--spacing-medium) 0',
                  color: 'var(--color-sea-green)',
                  fontSize: '1.1rem',
                  fontWeight: 'bold'
                }}>
                  ⚡ Instant Model Switch
                </h4>

                {/* Quick Switch Buttons */}
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                  gap: 'var(--spacing-small)',
                  marginBottom: 'var(--spacing-medium)'
                }}>
                  {/* GPT-5 Mini */}
                  <Button
                    size="small"
                    variant={selectedModel === 'openai/gpt-5-mini' ? 'primary' : 'secondary'}
                    on_click={() => {
                      setSelectedModel('openai/gpt-5-mini');
                      setHasUserSelectedModel(true);
                      localStorage.setItem('selectedAIModel', 'openai/gpt-5-mini');
                    }}
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      padding: 'var(--spacing-small)',
                      minHeight: '60px',
                      boxShadow: selectedModel === 'openai/gpt-5-mini' ? '0 4px 16px rgba(0, 114, 114, 0.3)' : 'none'
                    }}
                  >
                    <div style={{ fontSize: '1.2rem', marginBottom: '0.25rem' }}>🚀</div>
                    <div style={{ fontSize: '0.875rem', fontWeight: 'bold' }}>GPT-5 Mini</div>
                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>Fast • Latest</div>
                  </Button>

                  {/* GPT-4o Mini */}
                  <Button
                    size="small"
                    variant={selectedModel === 'openai/gpt-4o-mini' ? 'primary' : 'secondary'}
                    on_click={() => {
                      setSelectedModel('openai/gpt-4o-mini');
                      setHasUserSelectedModel(true);
                      localStorage.setItem('selectedAIModel', 'openai/gpt-4o-mini');
                    }}
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      padding: 'var(--spacing-small)',
                      minHeight: '60px',
                      boxShadow: selectedModel === 'openai/gpt-4o-mini' ? '0 4px 16px rgba(0, 114, 114, 0.3)' : 'none'
                    }}
                  >
                    <div style={{ fontSize: '1.2rem', marginBottom: '0.25rem' }}>⚡</div>
                    <div style={{ fontSize: '0.875rem', fontWeight: 'bold' }}>GPT-4o Mini</div>
                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>Fast • Reliable</div>
                  </Button>

                  {/* Claude 3.5 Sonnet */}
                  <Button
                    size="small"
                    variant={selectedModel === 'anthropic/claude-3.5-sonnet' ? 'primary' : 'secondary'}
                    on_click={() => {
                      setSelectedModel('anthropic/claude-3.5-sonnet');
                      setHasUserSelectedModel(true);
                      localStorage.setItem('selectedAIModel', 'anthropic/claude-3.5-sonnet');
                    }}
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      padding: 'var(--spacing-small)',
                      minHeight: '60px',
                      boxShadow: selectedModel === 'anthropic/claude-3.5-sonnet' ? '0 4px 16px rgba(0, 114, 114, 0.3)' : 'none'
                    }}
                  >
                    <div style={{ fontSize: '1.2rem', marginBottom: '0.25rem' }}>🧠</div>
                    <div style={{ fontSize: '0.875rem', fontWeight: 'bold' }}>Claude 3.5</div>
                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>Smart • Accurate</div>
                  </Button>

                  {/* Gemini 2.5 Flash */}
                  <Button
                    size="small"
                    variant={selectedModel === 'google/gemini-2.5-flash' ? 'primary' : 'secondary'}
                    on_click={() => {
                      setSelectedModel('google/gemini-2.5-flash');
                      setHasUserSelectedModel(true);
                      localStorage.setItem('selectedAIModel', 'google/gemini-2.5-flash');
                    }}
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      padding: 'var(--spacing-small)',
                      minHeight: '60px',
                      boxShadow: selectedModel === 'google/gemini-2.5-flash' ? '0 4px 16px rgba(0, 114, 114, 0.3)' : 'none'
                    }}
                  >
                    <div style={{ fontSize: '1.2rem', marginBottom: '0.25rem' }}>💎</div>
                    <div style={{ fontSize: '0.875rem', fontWeight: 'bold' }}>Gemini Flash</div>
                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>Fast • Free</div>
                  </Button>
                </div>

                {/* Real-time Status */}
                <div style={{
                  background: 'rgba(0, 114, 114, 0.05)',
                  borderRadius: '8px',
                  padding: 'var(--spacing-small)',
                  borderLeft: '4px solid var(--color-sea-green)',
                  fontSize: '0.875rem'
                }}>
                  <strong>🎯 Active Model:</strong> {selectedModel} •
                  <span style={{ color: 'var(--color-sea-green)' }}> Ready for Analysis</span>
                </div>
              </div>

              {/* 📊 MODEL COMPARISON DASHBOARD */}
              <div style={{
                background: 'linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 248, 248, 0.95) 100%)',
                borderRadius: '12px',
                padding: 'var(--spacing-medium)',
                marginBottom: 'var(--spacing-medium)',
                boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
                border: '1px solid rgba(0, 114, 114, 0.1)'
              }}>
                <h4 style={{
                  margin: '0 0 var(--spacing-medium) 0',
                  color: 'var(--color-sea-green)',
                  fontSize: '1.1rem',
                  fontWeight: 'bold'
                }}>
                  📊 Live Model Comparison
                </h4>

                {/* Model Stats Grid */}
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
                  gap: 'var(--spacing-small)',
                  marginBottom: 'var(--spacing-medium)'
                }}>
                  {[
                    { model: 'openai/gpt-5-mini', name: 'GPT-5 Mini', speed: '⚡ Ultra Fast', accuracy: '96%', cost: '💰 Medium' },
                    { model: 'openai/gpt-4o-mini', name: 'GPT-4o Mini', speed: '⚡ Fast', accuracy: '94%', cost: '💰 Low' },
                    { model: 'anthropic/claude-3.5-sonnet', name: 'Claude 3.5', speed: '🔥 Fast', accuracy: '98%', cost: '💰 Medium' },
                    { model: 'google/gemini-2.5-flash', name: 'Gemini Flash', speed: '⚡ Ultra Fast', accuracy: '92%', cost: '🆓 Free' }
                  ].map((modelInfo) => {
                    const isActive = selectedModel === modelInfo.model;
                    return (
                      <div
                        key={modelInfo.model}
                        style={{
                          background: isActive ? 'linear-gradient(135deg, var(--color-sea-green), var(--color-mint-green))' : 'white',
                          color: isActive ? 'white' : 'var(--dnb-text)',
                          padding: 'var(--spacing-small)',
                          borderRadius: '8px',
                          border: isActive ? 'none' : '2px solid rgba(0, 114, 114, 0.1)',
                          boxShadow: isActive ? '0 4px 16px rgba(0, 114, 114, 0.3)' : '0 2px 8px rgba(0, 0, 0, 0.05)',
                          transition: 'all 0.2s ease',
                          cursor: 'pointer',
                          transform: isActive ? 'scale(1.02)' : 'scale(1)'
                        }}
                        onClick={() => {
                          setSelectedModel(modelInfo.model);
                          setHasUserSelectedModel(true);
                          localStorage.setItem('selectedAIModel', modelInfo.model);
                        }}
                      >
                        <div style={{ fontWeight: 'bold', fontSize: '0.875rem', marginBottom: '0.25rem' }}>
                          {modelInfo.name}
                        </div>
                        <div style={{ fontSize: '0.75rem', opacity: isActive ? 0.9 : 0.7 }}>
                          {modelInfo.speed}
                        </div>
                        <div style={{ fontSize: '0.75rem', opacity: isActive ? 0.9 : 0.7 }}>
                          Accuracy: {modelInfo.accuracy}
                        </div>
                        <div style={{ fontSize: '0.75rem', opacity: isActive ? 0.9 : 0.7 }}>
                          {modelInfo.cost}
                        </div>
                      </div>
                    );
                  })}
                </div>

                {/* Quick Actions */}
                <div style={{
                  display: 'flex',
                  flexWrap: 'wrap',
                  gap: 'var(--spacing-small)',
                  justifyContent: 'space-between'
                }}>
                  <Button
                    size="small"
                    variant="tertiary"
                    on_click={() => {
                      // Test current model with sample fraud text
                      setText('BankID utløper snart. Forny nå på lenken: https://fake-bankid.no');
                    }}
                    style={{ fontSize: '0.875rem' }}
                  >
                    🧪 Test Current Model
                  </Button>

                  <Button
                    size="small"
                    variant="tertiary"
                    on_click={() => {
                      // Compare all models side by side
                      alert('Model comparison coming soon! 🚀');
                    }}
                    style={{ fontSize: '0.875rem' }}
                  >
                    📊 Compare All
                  </Button>
                </div>
              </div>

              {isLoadingModels ? (
                <div style={{ padding: 'var(--spacing-medium)', textAlign: 'center' }}>
                  <P>Laster tilgjengelige modeller...</P>
                </div>
              ) : (
                <div>
                  {/* Admin Controls Header */}
                  <div style={{ 
                    marginBottom: 'var(--spacing-medium)',
                    padding: 'var(--spacing-medium)',
                    background: 'var(--color-mint-green-12)',
                    borderRadius: '8px',
                    border: '2px solid var(--color-sea-green)'
                  }}>
                    <h3 style={{ margin: 0, marginBottom: 'var(--spacing-small)' }}>🔧 Admin Model Management</h3>
                    
                    {/* Statistics */}
                    <div style={{ marginBottom: 'var(--spacing-medium)' }}>
                      <P size="small">
                        {availableModels.length > 0 ? (
                          <>
                            📊 <strong>{availableModels.length}</strong> total models | 
                            ✅ <strong>{availableModels.filter(m => m.status === 'verified' || modelTestResults[m.id]?.working).length}</strong> verified | 
                            ⚠️ <strong>{availableModels.filter(m => m.status === 'untested' && !modelTestResults[m.id]).length}</strong> untested |
                            ❌ <strong>{availableModels.filter(m => m.status === 'failed' || modelTestResults[m.id]?.working === false).length}</strong> failed
                          </>
                        ) : (
                          'Loading models...'
                        )}
                      </P>
                    </div>
                    
                    {/* Action Buttons */}
                    <div style={{ 
                      display: 'flex', 
                      gap: 'var(--spacing-small)', 
                      flexWrap: 'wrap',
                      marginBottom: 'var(--spacing-small)'
                    }}>
                      <Button
                        size="small"
                        variant="primary"
                        disabled={isLoadingModels}
                        on_click={() => fetchAvailableModels(true)}
                      >
                        {isLoadingModels ? 'Fetching...' : '🔄 Fetch All Models'}
                      </Button>
                      
                      <Button
                        size="small"
                        variant="secondary"
                        disabled={batchTesting || availableModels.length === 0}
                        on_click={testTopModels}
                      >
                        {batchTesting ? 'Testing...' : '🧪 Test Top 50 Models'}
                      </Button>
                      
                      <Button
                        size="small"
                        variant="tertiary"
                        on_click={() => {
                          // Clear test results cache
                          localStorage.removeItem('modelTestResults');
                          setModelTestResults({});

                          // Clear selected model and reset to default
                          localStorage.removeItem('selectedAIModel');
                          setSelectedModel(defaultModel);
                          setHasUserSelectedModel(false);
                          setPendingModel('');

                          // Reset all models to their original status
                          setAvailableModels(prev => prev.map(model => ({
                            ...model,
                            status: model.working ? 'verified' : 'untested'
                          })));
                        }}
                      >
                        🗑️ Clear Cache & Reset
                      </Button>
                    </div>
                    
                    {/* Filter Input */}
                    <div style={{ marginBottom: 'var(--spacing-small)' }}>
                      <input
                        type="text"
                        placeholder="🔍 Filter models (e.g., 'gpt', 'claude', 'free', 'fast')..."
                        value={modelFilter}
                        onChange={(e) => setModelFilter(e.target.value)}
                        style={{
                          width: '100%',
                          padding: 'var(--spacing-small)',
                          border: '2px solid var(--color-sea-green-30)',
                          borderRadius: '4px',
                          fontSize: 'var(--font-size-basis)'
                        }}
                      />
                    </div>
                  </div>
                  <Dropdown
                    label="AI Model (Admin Mode)"
                    value={pendingModel || selectedModel}
                    on_change={handleModelChange}
                    size="small"
                    data={
                      availableModels.length > 0
                        ? availableModels
                            .filter((model: any) => {
                              if (!modelFilter) return true;
                              const search = modelFilter.toLowerCase();
                              return (
                                model.id.toLowerCase().includes(search) ||
                                model.name.toLowerCase().includes(search) ||
                                (model.provider && model.provider.toLowerCase().includes(search)) ||
                                (model.cost && model.cost.toLowerCase().includes(search)) ||
                                (model.speed && model.speed.toLowerCase().includes(search)) ||
                                (search === 'json' && model.supportsJson) ||
                                (search === 'verified' && model.status === 'verified') ||
                                (search === 'untested' && model.status === 'untested') ||
                                (search === 'failed' && model.status === 'failed')
                              );
                            })
                            .map((model: any) => {
                            // Merge with local test results
                            const testResult = modelTestResults[model.id];
                            const status = testResult ? 
                              (testResult.working ? 'verified' : 'failed') : 
                              model.status;
                            
                            let statusIcon = '';
                            if (status === 'verified') statusIcon = '✅';
                            else if (status === 'failed') statusIcon = '❌';
                            else if (status === 'untested') statusIcon = '⚠️';
                            
                            let content = `${statusIcon} ${model.name}`;
                            
                            // Add badges
                            if (model.supportsJson || testResult?.supportsJson) content += ' [JSON]';
                            if (model.cost === 'free') content += ' 🆓';
                            if (model.speed === 'fast') content += ' ⚡';
                            else if (model.speed === 'slow') content += ' 🐢';
                            
                            // Show provider
                            const provider = model.provider || model.id.split('/')[0];
                            content = `[${provider}] ${content}`;
                            
                            return {
                              value: model.id,
                              content
                            };
                          })
                        : [
                            // Fallback to static list if dynamic fetching fails
                            { value: 'openai/gpt-4o-mini', content: '✅ [OpenAI] GPT-4o Mini ⚡' },
                            { value: 'openai/gpt-5-mini', content: '✅ [OpenAI] GPT-5 Mini ⚡' },
                            { value: 'openai/gpt-4o', content: '✅ [OpenAI] GPT-4o' },
                            { value: 'anthropic/claude-3.5-sonnet', content: '✅ [Anthropic] Claude 3.5 Sonnet' },
                            { value: 'google/gemini-1.5-flash', content: '✅ [Google] Gemini 1.5 Flash ⚡' },
                            { value: 'meta-llama/llama-3.3-70b-instruct', content: '✅ [Meta] Llama 3.3 🆓' }
                          ]
                    }
                  />
                  
                  {/* Show test button for selected untested model */}
                  {availableModels.length > 0 && (
                    (() => {
                      const currentModel = availableModels.find(m => m.id === (pendingModel || selectedModel));
                      const testResult = modelTestResults[(pendingModel || selectedModel)];
                      const needsTest = currentModel && currentModel.status === 'untested' && !testResult;
                      
                      if (needsTest) {
                        return (
                          <div style={{ marginTop: 'var(--spacing-small)' }}>
                            <Button
                              size="small"
                              variant="secondary"
                              disabled={testingModel !== null}
                              on_click={() => testModel(pendingModel || selectedModel)}
                            >
                              {testingModel === (pendingModel || selectedModel) ? 'Testing...' : 'Test This Model'}
                            </Button>
                            {currentModel.status === 'untested' && (
                              <P size="small" style={{ marginTop: 'var(--spacing-x-small)', color: 'var(--color-signal-orange)' }}>
                                ⚠️ This model has not been verified. Test it first to ensure it works.
                              </P>
                            )}
                          </div>
                        );
                      }
                      
                      if (testResult && !testResult.working) {
                        let errorMessage = '';
                        let errorIcon = '❌';
                        
                        switch (testResult.errorType) {
                          case 'json_format':
                            errorIcon = '⚠️';
                            errorMessage = 'Model doesn\'t follow JSON format instructions';
                            break;
                          case 'timeout':
                            errorIcon = '⏱️';
                            errorMessage = 'Model response too slow (>15s)';
                            break;
                          case 'rate_limit':
                            errorIcon = '🚫';
                            errorMessage = 'API rate limit reached - try again later';
                            break;
                          case 'auth':
                            errorIcon = '🔑';
                            errorMessage = 'API key issue - check configuration';
                            break;
                          case 'not_found':
                            errorIcon = '❓';
                            errorMessage = 'Model unavailable or deprecated';
                            break;
                          case 'network':
                            errorIcon = '🌐';
                            errorMessage = 'Network connection issue';
                            break;
                          default:
                            errorMessage = testResult.error || 'Test failed - unknown error';
                        }
                        
                        return (
                          <P size="small" style={{ marginTop: 'var(--spacing-x-small)', color: 'var(--color-cherry-red)' }}>
                            {errorIcon} {errorMessage}
                            {testResult.error && testResult.errorType !== 'other' && (
                              <span style={{ fontSize: '0.8em', opacity: 0.7, display: 'block' }}>
                                Details: {testResult.error}
                              </span>
                            )}
                          </P>
                        );
                      }
                      
                      return null;
                    })()
                  )}
                </div>
              )}
              {pendingModel && pendingModel !== selectedModel && (
                <div style={{ 
                  marginTop: 'var(--spacing-small)', 
                  display: 'flex', 
                  gap: 'var(--spacing-small)' 
                }}>
                  <Button 
                    size="small" 
                    on_click={handleSaveModel}
                  >
                    Lagre modell
                  </Button>
                  <Button 
                    size="small" 
                    variant="secondary"
                    on_click={handleCancelModel}
                  >
                    Avbryt
                  </Button>
                </div>
              )}
            </div>

          {/* Close admin container div from line 833 */}
          </div>

          {/* End of showModelSelector admin section */}
          )}

          {/* Model Indicator Badge */}
          {hasUserSelectedModel && (
            <div style={{
              textAlign: 'center',
              marginBottom: 'var(--spacing-x-small)'
            }}>
              <Badge
                style={{
                  backgroundColor: 'var(--color-ocean-blue)',
                  color: 'white',
                  fontSize: '0.75rem'
                }}
              >
                Using: {selectedModel.split('/')[1] || selectedModel}
              </Badge>
            </div>
          )}

          <div className="button-container">
            {result && !isAnalyzing ? (
              <button
                className="check-button"
                onClick={() => {
                  // Reset for new analysis
                  setText('');
                  setResult(null);
                  setAiAnalysis(null);
                  setImagePreview(null);
                  setOcrProgress(0);
                }}
              >
                🔄 Ny analyse
              </button>
            ) : (
              <button
                className="check-button"
                onClick={handleCheck}
                disabled={(text.trim().length < 5 && !imagePreview) || isAnalyzing || isProcessingImage}
              >
                {isAnalyzing ? 'Sjekker...' : 'Sjekk'}
              </button>
            )}
            <button 
              className="upload-button"
              onClick={() => fileInputRef.current?.click()}
              disabled={isProcessingImage}
            >
              📷 Last opp bilde
            </button>
          </div>

          {/* Dynamic message based on analysis */}
          {result && result.summary && (
            <div className="text-prompt">
              <p>{result.summary}</p>
            </div>
          )}

          {/* Loading state */}
          {isAnalyzing && (
            <div className="analyzing-state">
              <div className="analyzing-spinner"></div>
              <p>Analyserer med AI...</p>
            </div>
          )}

          {/* Result */}
          {result && !isAnalyzing && (
            <div className={getRiskClass()}>
              {/* Show when this is from an image analysis */}
              {result.isImageAnalysis && (
                <div style={{ marginBottom: '12px' }}>
                  <p style={{ fontWeight: 600, fontSize: '0.9rem', color: 'var(--dnb-text)' }}>
                    📸 Bildeanalyse fullført
                  </p>
                </div>
              )}
              <div className="result-header">
                <div style={{ width: '100%' }}>
                  {result.category === 'fraud' ? (
                    <>
                      <div className="result-score">{result.score}%</div>
                      <div className="result-label">
                        sannsynlighet for svindel
                      </div>
                    </>
                  ) : result.category === 'marketing' ? (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '8px',
                        fontSize: '1.25rem',
                        fontWeight: 600,
                        color: 'var(--dnb-text)'
                      }}>
                        <span>📢</span>
                        <span>Markedsføring</span>
                      </div>
                      <div style={{
                        fontSize: '0.875rem',
                        color: 'var(--dnb-text-muted)',
                        marginLeft: '36px'
                      }}>
                        Kommersiell melding fra kjent avsender
                      </div>
                    </div>
                  ) : result.category === 'suspicious' ? (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '8px',
                        fontSize: '1.25rem',
                        fontWeight: 600,
                        color: 'var(--dnb-text)'
                      }}>
                        <span>⚠️</span>
                        <span>Mistenkelig</span>
                      </div>
                      <div style={{
                        fontSize: '0.875rem',
                        color: 'var(--dnb-text-muted)',
                        marginLeft: '36px'
                      }}>
                        Verifiser avsender før du handler
                      </div>
                    </div>
                  ) : result.category === 'safe' ? (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '8px',
                        fontSize: '1.25rem',
                        fontWeight: 600,
                        color: 'var(--dnb-text)'
                      }}>
                        <span>🔒</span>
                        <span>Trygt</span>
                      </div>
                      <div style={{
                        fontSize: '0.875rem',
                        color: 'var(--dnb-text-muted)',
                        marginLeft: '36px'
                      }}>
                        Ingen tegn på svindel funnet
                      </div>
                    </div>
                  ) : result.category === 'error' ? (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '8px',
                        fontSize: '1.25rem',
                        fontWeight: 600,
                        color: 'var(--color-signal-orange)'
                      }}>
                        <span>⚠️</span>
                        <span>Analyse utilgjengelig</span>
                      </div>
                      <div style={{
                        fontSize: '0.875rem',
                        color: 'var(--dnb-text-muted)',
                        marginLeft: '36px'
                      }}>
                        {(result as any).retryable ?
                          'For mange forespørsler akkurat nå. Vær ekstra forsiktig.' :
                          'Kunne ikke analysere innholdet. Vær ekstra forsiktig.'
                        }
                      </div>
                      {(result as any).retryable && (
                        <div style={{ marginLeft: '36px', marginTop: '8px' }}>
                          <Button
                            size="small"
                            variant="secondary"
                            on_click={() => {
                              // Retry the analysis
                              handleCheck();
                            }}
                          >
                            Prøv igjen
                          </Button>
                        </div>
                      )}
                    </div>
                  ) : (
                    // Fallback to old display for backward compatibility
                    <>
                      {result.category === 'fraud' && result.score !== undefined && (
                        <>
                          <div className="result-score">{result.score}%</div>
                          <div className="result-label">
                            sannsynlighet for svindel
                          </div>
                        </>
                      )}
                      {result.category !== 'fraud' && (
                        <div className="result-label">{result.category || 'Ukjent'}
                          {(result as any).fallbackMode && (
                            <span style={{
                              display: 'block',
                              fontSize: '0.75rem',
                              marginTop: '4px',
                              color: 'var(--dnb-text-muted)'
                            }}>
                              (AI utilgjengelig)
                            </span>
                          )}
                        </div>
                      )}
                    </>
                  )}
                </div>
              </div>

              {result.category !== 'fraud' && result.category !== 'marketing' && result.category !== 'suspicious' && result.category !== 'safe' && result.category !== 'error' && (
                <div className="result-message">
                  {getRiskMessage()}
                </div>
              )}

              {/* AI Analysis Section */}
              {aiAnalysis && (
                <div style={{ 
                  marginTop: 'var(--spacing-medium)', 
                  padding: 'var(--spacing-small)',
                  background: aiAnalysis.error ? 'rgba(194, 30, 37, 0.05)' : 'rgba(0, 114, 114, 0.05)',
                  borderRadius: '8px'
                }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 'var(--spacing-small)', marginBottom: 'var(--spacing-small)', flexWrap: 'wrap' }}>
                    <Badge type={aiAnalysis.error ? "error" : "information"}>
                      {aiAnalysis.error ? 'AI-feil' : 'AI-analysert'}
                    </Badge>
                    {!aiAnalysis.error && hasUserSelectedModel && (
                      <span style={{
                        fontSize: '0.75rem',
                        color: 'var(--dnb-text-muted)',
                        whiteSpace: 'nowrap',
                        minWidth: '0' // Allow shrinking if needed
                      }}>
                        {selectedModel && typeof selectedModel === 'string' ? selectedModel.split('/')[1] : 'AI'}
                      </span>
                    )}
                  </div>
                  {aiAnalysis.error ? (
                    <P size="small" style={{ color: 'var(--color-cherry-red)' }}>
                      {aiAnalysis.error}
                    </P>
                  ) : (
                    <>
                      <P size="small" style={{ marginBottom: 'var(--spacing-small)' }}>
                        {aiAnalysis.summary}
                      </P>
                      {aiAnalysis.recommendation && (
                        <P size="small" style={{ fontWeight: 500 }}>
                          <strong>Anbefaling:</strong> {aiAnalysis.recommendation}
                        </P>
                      )}
                    </>
                  )}
                </div>
              )}

              {/* REVOLUTIONARY Context Refinement Section - Always Prominent */}
              {originalText && !result.contextRefined && (
                <div style={{
                  marginTop: 'var(--spacing-large)',
                  padding: 'var(--spacing-large)',
                  background: 'linear-gradient(135deg, rgba(64, 191, 191, 0.08) 0%, rgba(0, 114, 114, 0.05) 100%)',
                  borderRadius: '16px',
                  border: '2px solid var(--color-sea-green)',
                  boxShadow: '0 8px 32px rgba(0, 114, 114, 0.1)'
                }}>
                  {/* Attention-Grabbing Header */}
                  <div style={{ textAlign: 'center', marginBottom: 'var(--spacing-medium)' }}>
                    <div style={{ fontSize: '2.5rem', marginBottom: 'var(--spacing-small)' }}>💡</div>
                    <Heading size="large" style={{
                      color: 'var(--color-sea-green)',
                      margin: '0 0 var(--spacing-x-small) 0',
                      fontWeight: 'bold'
                    }}>
                      Har du mer informasjon?
                    </Heading>
                    <P style={{
                      color: 'var(--dnb-text)',
                      margin: 0,
                      fontSize: '1.1rem',
                      fontWeight: 500
                    }}>
                      Vi kan gi deg en mer presis analyse
                    </P>
                  </div>

                  {/* LLM-Generated Questions - Clickable Pills */}
                  {followUpQuestions.length > 0 && (
                    <div style={{ marginBottom: 'var(--spacing-medium)' }}>
                      <P size="small" style={{
                        fontWeight: 600,
                        marginBottom: 'var(--spacing-small)',
                        color: 'var(--color-sea-green)'
                      }}>
                        📝 Klikk på spørsmål som passer:
                      </P>
                      <div style={{
                        display: 'flex',
                        flexWrap: 'wrap',
                        gap: 'var(--spacing-small)'
                      }}>
                        {followUpQuestions.map((question, index) => (
                          <Button
                            key={index}
                            variant="secondary"
                            size="small"
                            on_click={() => handleQuestionClick(question)}
                            style={{
                              padding: '0.75rem 1rem',
                              borderRadius: '20px',
                              fontSize: '0.9rem',
                              background: 'var(--color-white)',
                              border: '2px solid var(--color-mint-green)',
                              color: 'var(--color-sea-green)',
                              fontWeight: 500,
                              transition: 'all 0.2s ease',
                              boxShadow: '0 2px 8px rgba(0, 114, 114, 0.1)'
                            }}
                          >
                            {question}
                          </Button>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Always Visible Text Input */}
                  <div style={{ marginBottom: 'var(--spacing-medium)' }}>
                    <Textarea
                      label="💬 Eller fortell oss mer med dine egne ord:"
                      placeholder="F.eks: 'Jeg forventer ikke denne samtalen', 'Kjenner ikke dette nummeret', 'Dette virker mistenkelig fordi...'"
                      value={contextText}
                      on_change={({ value }: { value: string }) => setContextText(value)}
                      rows={3}
                      style={{
                        borderRadius: '12px',
                        border: '2px solid var(--color-mint-green)',
                        padding: '1rem'
                      }}
                    />
                  </div>

                  {/* Prominent Action Button */}
                  <div style={{ textAlign: 'center' }}>
                    <Button
                      size="large"
                      on_click={handleContextRefinement}
                      disabled={!contextText.trim() || isRefiningAnalysis}
                      style={{
                        padding: '1rem 2rem',
                        fontSize: '1.1rem',
                        fontWeight: 600,
                        borderRadius: '12px',
                        background: 'var(--color-sea-green)',
                        minWidth: '200px',
                        boxShadow: '0 4px 16px rgba(0, 114, 114, 0.3)'
                      }}
                    >
                      {isRefiningAnalysis ? (
                        <>
                          <span style={{ marginRight: '0.5rem' }}>⚡</span>
                          Analyserer...
                        </>
                      ) : (
                        <>
                          <span style={{ marginRight: '0.5rem' }}>🔍</span>
                          Oppdater analyse
                        </>
                      )}
                    </Button>
                  </div>
                </div>
              )}

              {/* Show if analysis was refined with context */}
              {result.contextRefined && (
                <div style={{
                  marginTop: 'var(--spacing-medium)',
                  padding: 'var(--spacing-small)',
                  background: 'rgba(0, 114, 114, 0.05)',
                  borderRadius: '8px'
                }}>
                  <Badge type="success">
                    Analyse oppdatert med kontekst
                  </Badge>
                </div>
              )}

              {result.risk === 'high' && (
                <div className="result-recommendations">
                  <div className="recommendation">
                    <span>🗑️</span>
                    <span>Slett meldingen umiddelbart</span>
                  </div>
                  <div className="recommendation">
                    <span>🚫</span>
                    <span>Ikke klikk på lenker eller oppgi informasjon</span>
                  </div>
                  <div className="recommendation">
                    <span>⚠️</span>
                    <span>Hvis du har oppgitt info: Ring DNB på 915 04800</span>
                  </div>
                </div>
              )}
              
              {result.risk === 'medium' && (
                <div className="result-recommendations">
                  <div className="recommendation">
                    <span>⚠️</span>
                    <span>Vær ekstra forsiktig</span>
                  </div>
                  <div className="recommendation">
                    <span>✔️</span>
                    <span>Sjekk avsender nøye</span>
                  </div>
                  <div className="recommendation">
                    <span>📞</span>
                    <span>Kontakt DNB direkte hvis du er usikker</span>
                  </div>
                </div>
              )}
              
              {result.risk === 'low' && (
                <div className="result-recommendations">
                  <div className="recommendation">
                    <span>✅</span>
                    <span>Dette ser legitimt ut</span>
                  </div>
                  <div className="recommendation">
                    <span>👀</span>
                    <span>Vær alltid oppmerksom på tegn til svindel</span>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Close input-card div */}
        </div>

      </main>

      {/* Footer */}
      <footer className="footer">
        <p className="footer-text">
          DNB Svindelsjekk • Ring oss på <span className="footer-phone">915 04800</span> hvis du er usikker
        </p>
        <p className="footer-copyright">© {new Date().getFullYear()} DNB</p>
        <p style={{ fontSize: '0.75rem', color: '#666', marginTop: '0.5rem' }}>
          v2025.09.15 • Improved fraud detection
        </p>
      </footer>
    </div>
  );
}